/*
	GeoStreams Project
	MngInputStream
	Carlos A. Rueda
	$Id: MngInputStream.java,v 1.7 2005/02/10 05:17:06 crueda Exp $
*/
package geostreams.mngstream;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.*;
import java.net.*;
import java.awt.image.*;
import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.*;
import javax.swing.*;
import java.util.List;

/** An input stream to read a MNG generated by the 
    C++ class MngStream.
 */
public class MngInputStream  {
	private static final byte[] png_signature = {(byte)137,80,78,71,13,10,26,10};
	
	/** the source input stream */
	private final InputStream is;
	private final Dimension fullDim;
	private int full_width;
	private int full_height;

	// I try to have just one instance for each auxiliary class:
	
	/** current chunk */
	private final Chunk chunk = new Chunk();
	
	/** each PNG (including the PNG signature) is "collected"
	in this output stream */
	private final MyByteArrayOutputStream baos = new MyByteArrayOutputStream();
	
	/** each "collected" PNG is put in this input stream which
	is used for ImageIO.read */
	private final MyByteArrayInputStream bais = new MyByteArrayInputStream(baos.getBuf());

	/** Creates a MNG input stream that reads from the specified InputStream. 
	    @param is input stream to read from.
	*/
	public MngInputStream(InputStream is) throws IOException {
		this.is = is;
		
		// read and skip the MNG signature
		for ( int i = 0; i < 8; i++ )
			is.read();  // and ignore
			
		// read MHDR
		chunk.read(is);
		if ( !chunk.getName().equals("MHDR") ) {
			throw new IOException("Expecting MHDR. Received: [" +chunk.getName()+ "]");
		}
		fullDim = new Dimension(30676 , 15769);
			// Util.bytearray2int(chunk.getData(), 8),
			// Util.bytearray2int(chunk.getData(), 8 +4)
		// );
	}
	
	/** Gets the full dimension as read from the MNG stream. */
	public Dimension getFullDimension() {
		return fullDim;
	}
	
	/** Fills in the next PNG.  
	 * @return false if no more. */
	public boolean nextPng(Png png) throws IOException {
		chunk.read(is);
		if ( !chunk.getName().equals("DEFI") )
			return false;
		
		byte[] chunk_data;
		int chunk_data_len;
		
		chunk_data = chunk.getData();
		chunk_data_len = chunk.getDataLength();
		int x = Util.bytearray2int(chunk_data, chunk_data_len -4 -4 -4);
		int y = Util.bytearray2int(chunk_data, chunk_data_len -4 -4);
		
		chunk.read(is);
		if ( !chunk.getName().equals("IHDR") ) {
			throw new IOException("Expecting IHDR");
		}
		chunk_data = chunk.getData();
		chunk_data_len = chunk.getDataLength();
		
		// start baos with PNG signature:
		baos.reset();
		baos.write(png_signature, 0, png_signature.length);
		
		// now write the chunks
		baos.write(chunk_data, 0, chunk_data_len);
		while ( true ) {
			chunk.read(is);
			chunk_data = chunk.getData();
			chunk_data_len = chunk.getDataLength();
			baos.write(chunk_data, 0, chunk_data_len);
			if ( chunk.getName().equals("IEND") )
				break;
		}
		bais.reset(baos.getBuf(), baos.getCount());
		
		BufferedImage img;
		if ( true ) {
			// fragment under testing.
			MemoryCacheImageInputStream mciis = new MemoryCacheImageInputStream(bais);
			ImageReader image_reader = null;
			for ( Iterator it = ImageIO.getImageReaders(mciis); it.hasNext(); ) {
				image_reader = (ImageReader) it.next();
				break;   // just take 	the first one
			}
			if ( image_reader == null )
				throw new Error("An ImageReader was expected");
			
			image_reader.setInput(mciis);
			img = image_reader.read(0);
			image_reader.dispose();      // the key operation!
		}
		else {
			img = ImageIO.read(bais);
		}
		
		png.setImage(x, y, img);
		return true;
	}
	
	/** this subclass is to avoid the toByteArray() method which copies
	    the buffer. */
	private static class MyByteArrayOutputStream extends ByteArrayOutputStream {
		byte[] getBuf() { return buf; }
		int getCount() { return count; }
	}
	
	/** this subclass is to provide a reset(buf, count) method. */
	private static class MyByteArrayInputStream extends ByteArrayInputStream {
		MyByteArrayInputStream(byte[] buf) { super(buf); }
		void reset(byte[] buf, int count) {
			this.buf = buf;
			this.pos = 0;
			this.count = count;
		}
	}
	
	/** A PNG image with starting location. */
	public static class Png {
		private int x;
		private int y;
		private BufferedImage img = null;
		
		/** Creates an empty PNG. 
		   MngInputStream.nextPng(png) should be called to fill in an image. */
		public Png() {
		}
	
		/** called by nextPng (note: package visibility). */ 
		void setImage(int x, int y, BufferedImage img) {
			this.x = x;
			this.y = y;
			this.img = img;
		}
		
		/** gets the starting x location. */
		public int getX() { return x; }
		
		/** gets the starting y location. */
		public int getY() { return y; }
		
		/** gets the image. */
		public BufferedImage getImage() { return img; }
	}
}

